//$file${app::driver::uart::.::uart.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: g431b-esc.qm
// File:  ${app::driver::uart::.::uart.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${app::driver::uart::.::uart.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "stm32g4xx_hal.h"
#include "qpc.h"
#include "uart.h"
#include "stdio.h"
#include "string.h"
#include "appPubList.h"

Q_DEFINE_THIS_FILE

#define TX_BUFFER_SIZE       (512)

/* Inernal signals */
enum uartSignal {
    TICK_SIG = MAX_PUB_SIG,
    TRANSMIT_REQUEST_SIG,
    TRANSMIT_DONE_SIG,
    RX_DATA_AVAILABLE_SIG,
};

//$declare${app::driver::uart::uart} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::uart} .................................................
typedef struct {
// protected:
    QActive super;

// private:
    UART_HandleTypeDef * pHandle;
    DMA_HandleTypeDef * pTxDMA;
    DMA_HandleTypeDef * pRxDMA;
    uint8_t rxDmaBuffer[DMA_BUFFER_SIZE];
    uint32_t old_rx_pos;
    uint8_t txBuffer[TX_BUFFER_SIZE];
    uint16_t txBufHead;
    uint16_t txBufTail;
    uint16_t txLen;
} uart;

// protected:
static QState uart_initial(uart * const me, void const * const par);
static QState uart_TOP(uart * const me, QEvt const * const e);
static QState uart_IDLE(uart * const me, QEvt const * const e);
static QState uart_TRANSMITTING(uart * const me, QEvt const * const e);
//$enddecl${app::driver::uart::uart} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/* Local Object */
static uart l_uart;
static QEvt const * uartQueueSto[8];

/* Global Object: opaque pointer to AO */
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${app::driver::uart::AO_uart} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::AO_uart} ..............................................
QActive * const AO_uart = &l_uart.super;
//$enddef${app::driver::uart::AO_uart} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/* active object constructor */
//$define${app::driver::uart::UART_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::UART_ctor} ............................................
void UART_ctor(
    UART_HandleTypeDef * pHandle,
    DMA_HandleTypeDef * pTxDMA,
    DMA_HandleTypeDef * pRxDMA)
{
    Q_ASSERT((pHandle != NULL) && (pTxDMA != NULL) && (pRxDMA != NULL));

    uart * const me = &l_uart;
    me->pHandle = pHandle;
    me->pTxDMA = pTxDMA;
    me->pRxDMA = pRxDMA;

    QActive_ctor(&me->super, Q_STATE_CAST(&uart_initial));
    QACTIVE_START(&me->super,
                  AO_UART_PRIORITY,
                  uartQueueSto,
                  Q_DIM(uartQueueSto),
                  (void *)0,
                  0U,
                  (void *)0);

}
//$enddef${app::driver::uart::UART_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${app::driver::uart::uart} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::uart} .................................................

//${app::driver::uart::uart::SM} .............................................
static QState uart_initial(uart * const me, void const * const par) {
    //${app::driver::uart::uart::SM::initial}
    QS_OBJ_DICTIONARY(&l_uart);

    memset(me->txBuffer, 0, TX_BUFFER_SIZE);
    me->txBufHead = 0;
    me->txBufTail = 0;

    Q_ASSERT(HAL_OK == HAL_UARTEx_ReceiveToIdle_DMA(me->pHandle, me->rxDmaBuffer, DMA_BUFFER_SIZE));

    QS_FUN_DICTIONARY(&uart_TOP);
    QS_FUN_DICTIONARY(&uart_IDLE);
    QS_FUN_DICTIONARY(&uart_TRANSMITTING);

    return Q_TRAN(&uart_IDLE);
}

//${app::driver::uart::uart::SM::TOP} ........................................
static QState uart_TOP(uart * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::driver::uart::uart::SM::TOP::RX_DATA_AVAILABLE}
        case RX_DATA_AVAILABLE_SIG: {
            for(uint16_t i = 0; i < Q_EVT_CAST(uartMsgEvt)->bufLen; i++) {
                QS_RX_PUT(Q_EVT_CAST(uartMsgEvt)->buf[i]);
            }

            if(Q_EVT_CAST(uartMsgEvt)->bufLen > 0) {
                QS_rxParse();
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${app::driver::uart::uart::SM::TOP::IDLE} ..................................
static QState uart_IDLE(uart * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::driver::uart::uart::SM::TOP::IDLE::TRANSMIT_REQUEST}
        case TRANSMIT_REQUEST_SIG: {
            for(uint16_t i = 0; i < Q_EVT_CAST(uartMsgEvt)->bufLen; i++) {
                uint16_t lookAheadIdx = (me->txBufHead + 1) % TX_BUFFER_SIZE;
                if(lookAheadIdx == me->txBufTail) {
                    /* buffer full */
                    break;
                }
                me->txBuffer[me->txBufHead] = Q_EVT_CAST(uartMsgEvt)->buf[i];
                me->txBufHead = lookAheadIdx;
            }
            //${app::driver::uart::uart::SM::TOP::IDLE::TRANSMIT_REQUEST::[notEmpty]}
            if (me->txBufHead != me->txBufTail) {
                if(me->txBufHead > me->txBufTail) {
                    me->txLen = me->txBufHead - me->txBufTail;
                } else if(me->txBufHead < me->txBufTail) {
                    me->txLen = TX_BUFFER_SIZE - me->txBufTail;
                }

                HAL_UART_Transmit_DMA(me->pHandle, &(me->txBuffer[me->txBufTail]), me->txLen);

                status_ = Q_TRAN(&uart_TRANSMITTING);
            }
            //${app::driver::uart::uart::SM::TOP::IDLE::TRANSMIT_REQUEST::[else]}
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&uart_TOP);
            break;
        }
    }
    return status_;
}

//${app::driver::uart::uart::SM::TOP::TRANSMITTING} ..........................
static QState uart_TRANSMITTING(uart * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::driver::uart::uart::SM::TOP::TRANSMITTING::TRANSMIT_DONE}
        case TRANSMIT_DONE_SIG: {
            me->txBufTail = (me->txBufTail + me->txLen) % TX_BUFFER_SIZE;
            //${app::driver::uart::uart::SM::TOP::TRANSMITTING::TRANSMIT_DONE::[isDone]}
            if (me->txBufHead == me->txBufTail) {
                status_ = Q_TRAN(&uart_IDLE);
            }
            //${app::driver::uart::uart::SM::TOP::TRANSMITTING::TRANSMIT_DONE::[else]}
            else {
                if(me->txBufHead > me->txBufTail) {
                    me->txLen = me->txBufHead - me->txBufTail;
                } else if(me->txBufHead < me->txBufTail) {
                    me->txLen = TX_BUFFER_SIZE - me->txBufTail;
                }

                HAL_UART_Transmit_DMA(me->pHandle, &(me->txBuffer[me->txBufTail]), me->txLen);

                status_ = Q_HANDLED();
            }
            break;
        }
        //${app::driver::uart::uart::SM::TOP::TRANSMITTING::TRANSMIT_REQUEST}
        case TRANSMIT_REQUEST_SIG: {
            for(uint16_t i = 0; i < Q_EVT_CAST(uartMsgEvt)->bufLen; i++) {
                uint16_t lookAheadIdx = (me->txBufHead + 1) % TX_BUFFER_SIZE;
                if(lookAheadIdx == me->txBufTail) {
                    /* buffer full */
                    break;
                }
                me->txBuffer[me->txBufHead] = Q_EVT_CAST(uartMsgEvt)->buf[i];
                me->txBufHead = lookAheadIdx;
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&uart_TOP);
            break;
        }
    }
    return status_;
}
//$enddef${app::driver::uart::uart} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${app::driver::uart::UART_send} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::UART_send} ............................................
bool UART_send(
    uint8_t * const buf,
    const uint16_t size)
{
    Q_ASSERT(buf != NULL);
    int32_t remaining = size;
    uart * const me = &l_uart;
    uint16_t idx = 0;

    while(remaining > 0) {
        uint16_t bytesToTransfer = (remaining > DMA_BUFFER_SIZE) ? DMA_BUFFER_SIZE : remaining;

        uartMsgEvt * pTxEvt = Q_NEW(uartMsgEvt, TRANSMIT_REQUEST_SIG);
        memcpy(pTxEvt->buf, &(buf[idx]), bytesToTransfer);
        pTxEvt->bufLen = bytesToTransfer;
        if(true != QACTIVE_POST_X(AO_uart, (QEvt *)pTxEvt, 0U, me)) {
            return false;
        }

        remaining -= bytesToTransfer;
        idx += bytesToTransfer;
    }

    return true;
}
//$enddef${app::driver::uart::UART_send} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${app::driver::uart::HAL_UART_TxCpltCallback} vvvvvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::HAL_UART_TxCpltCallback} ..............................
void HAL_UART_TxCpltCallback(UART_HandleTypeDef * huart) {
    Q_ASSERT(huart != NULL);
    if(huart->Instance == USART2) {
        uart * const me = &l_uart;
        QEvt * pEvt = Q_NEW(QEvt, TRANSMIT_DONE_SIG);
        QACTIVE_POST(&me->super, pEvt, (void *)0);
    }
}
//$enddef${app::driver::uart::HAL_UART_TxCpltCallback} ^^^^^^^^^^^^^^^^^^^^^^^
//$define${app::driver::uart::HAL_UARTEx_RxEventCallback} vvvvvvvvvvvvvvvvvvvv

//${app::driver::uart::HAL_UARTEx_RxEventCallback} ...........................
void HAL_UARTEx_RxEventCallback(
    UART_HandleTypeDef * huart,
    uint16_t size)
{
    Q_ASSERT(huart != NULL);
    static QSpyId const l_UART_RxEvent = { 0U };

    if(huart->Instance == USART2) {
        uart * const me = &l_uart;
        if(size != me->old_rx_pos) {
            uartMsgEvt * pRxEvt = Q_NEW(uartMsgEvt, RX_DATA_AVAILABLE_SIG);
            memset(pRxEvt->buf, 0, DMA_BUFFER_SIZE);
            if(size > me->old_rx_pos) {
                pRxEvt->bufLen = size - me->old_rx_pos;
                memcpy(pRxEvt->buf, &(me->rxDmaBuffer[me->old_rx_pos]), pRxEvt->bufLen);
            } else {
                pRxEvt->bufLen = DMA_BUFFER_SIZE - me->old_rx_pos + size;
                size_t nByteToWrite = DMA_BUFFER_SIZE - me->old_rx_pos;
                memcpy(pRxEvt->buf, &(me->rxDmaBuffer[me->old_rx_pos]), nByteToWrite);
                memcpy(&(pRxEvt->buf[nByteToWrite]), &(me->rxDmaBuffer[0]), size);
            }
            QACTIVE_POST(AO_uart, (QEvt *)pRxEvt, &l_UART_RxEvent);
        }
        me->old_rx_pos = size;
    }
}
//$enddef${app::driver::uart::HAL_UARTEx_RxEventCallback} ^^^^^^^^^^^^^^^^^^^^

