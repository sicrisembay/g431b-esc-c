//$file${app::canopen::.::AO_canopen.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: g431b-esc.qm
// File:  ${app::canopen::.::AO_canopen.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${app::canopen::.::AO_canopen.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "stm32g4xx_hal.h"
#include "qpc.h"
#include "appPubList.h"
#include "AO_canopen.h"
#include "CANopen.h"
#include "OD.h"
#include "main.h"

/* Inernal signals */
enum canopenSignal {
    TICK_SIG = MAX_PUB_SIG,
    FAST_TICK_SIG,
    CAN_RX_SIG,
    OK_SIG,
    ERROR_SIG,
};

/* default values for CO_CANopenInit() */
#define NMT_CONTROL   CO_NMT_STARTUP_TO_OPERATIONAL     \
                    | CO_NMT_ERR_ON_ERR_REG             \
                    | CO_ERR_REG_GENERIC_ERR            \
                    | CO_ERR_REG_COMMUNICATION

#define FIRST_HB_TIME        500
#define SDO_SRV_TIMEOUT_TIME 1000
#define SDO_CLI_TIMEOUT_TIME 500
#define SDO_CLI_BLOCK        false
#define OD_STATUS_BITS       NULL

//$declare${app::canopen::canopen} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::canopen::canopen} ...................................................
typedef struct {
// protected:
    QActive super;

// private:
    QTimeEvt timerTick;
    QTimeEvt timerFastTick;
    CO_t * co;
    void * CANptr;
    IRQn_Type irq;
    uint8_t activeNodeId;
    uint16_t pendingBitRate;
    uint32_t timestamp_us_prev;
    uint32_t fast_timestamp_us_prev;
} canopen;

// protected:
static QState canopen_initial(canopen * const me, void const * const par);
static QState canopen_ALLOCATE(canopen * const me, QEvt const * const e);
static QState canopen_RESET(canopen * const me, QEvt const * const e);
static QState canopen_COMM_INIT(canopen * const me, QEvt const * const e);
static QState canopen_RUNNING(canopen * const me, QEvt const * const e);
//$enddecl${app::canopen::canopen} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

static canopen l_canopen;
static QEvt const * canopenQueueSto[8];

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${app::canopen::AO_canopen} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::canopen::AO_canopen} ................................................
QActive * const AO_canopen = &l_canopen.super;
//$enddef${app::canopen::AO_canopen} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${app::canopen::canopen} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::canopen::canopen} ...................................................

//${app::canopen::canopen::SM} ...............................................
static QState canopen_initial(canopen * const me, void const * const par) {
    //${app::canopen::canopen::SM::initial}
    QS_OBJ_DICTIONARY(&l_canopen);

    me->co = NULL;

    QS_FUN_DICTIONARY(&canopen_ALLOCATE);
    QS_FUN_DICTIONARY(&canopen_RESET);
    QS_FUN_DICTIONARY(&canopen_COMM_INIT);
    QS_FUN_DICTIONARY(&canopen_RUNNING);

    return Q_TRAN(&canopen_ALLOCATE);
}

//${app::canopen::canopen::SM::ALLOCATE} .....................................
static QState canopen_ALLOCATE(canopen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::canopen::canopen::SM::ALLOCATE}
        case Q_ENTRY_SIG: {
            CO_config_t * config_ptr = NULL;
            uint32_t heapMemoryUsed;
            me->co = CO_new(config_ptr, &heapMemoryUsed);

            if(me->co != NULL) {
                QS_BEGIN_ID(CANOPEN_INFO_RECORD, AO_canopen->prio);
                    QS_STR("CANopen allocated heap: ");
                    QS_U32(6, heapMemoryUsed);
                QS_END();
                QEvt * pEvt = Q_NEW(QEvt, OK_SIG);
                QACTIVE_POST(&me->super, pEvt, &me->super);
            } else {
                QS_BEGIN_ID(CANOPEN_ERROR_RECORD, AO_canopen->prio);
                    QS_STR("CANopen allocation failed!");
                QS_END();
                QEvt * pEvt = Q_NEW(QEvt, ERROR_SIG);
                QACTIVE_POST(&me->super, pEvt, &me->super);
            }

            status_ = Q_HANDLED();
            break;
        }
        //${app::canopen::canopen::SM::ALLOCATE::ERROR}
        case ERROR_SIG: {
            status_ = Q_TRAN(&canopen_RESET);
            break;
        }
        //${app::canopen::canopen::SM::ALLOCATE::OK}
        case OK_SIG: {
            status_ = Q_TRAN(&canopen_COMM_INIT);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${app::canopen::canopen::SM::RESET} ........................................
static QState canopen_RESET(canopen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::canopen::canopen::SM::RESET}
        case Q_ENTRY_SIG: {
            CO_CANsetConfigurationMode((void *)me->CANptr);
            CO_delete(me->co);

            QS_BEGIN_ID(CANOPEN_INFO_RECORD, (void *)0);
                QS_STR("CANopen device reset\r\n");
            QS_END();

            QS_FLUSH();

            NVIC_SystemReset();

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${app::canopen::canopen::SM::COMM_INIT} ....................................
static QState canopen_COMM_INIT(canopen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::canopen::canopen::SM::COMM_INIT}
        case Q_ENTRY_SIG: {
            CO_ReturnError_t err = CO_ERROR_NO;

            me->activeNodeId = CANOPEN_DEVICE_NODE_ID;
            me->pendingBitRate = CANOPEN_DEVICE_BITRATE_KBPS;

            me->co->CANmodule->CANnormal = false;
            me->co->CANmodule->irq = me->irq;

            /* Enter CAN configuration. */
            me->co->CANmodule->CANptr = me->CANptr;
            CO_CANmodule_disable(me->co->CANmodule);

            /* initialize CANopen */
            err = CO_CANinit(me->co, me->CANptr, me->pendingBitRate);
            if (err != CO_ERROR_NO) {
                QS_BEGIN_ID(CANOPEN_ERROR_RECORD, AO_canopen->prio);
                    QS_STR("CANopen initialization failed: ");
                    QS_I16(6, err);
                QS_END();
                QEvt * pEvt = Q_NEW(QEvt, ERROR_SIG);
                QACTIVE_POST(&me->super, pEvt, &me->super);
                return Q_HANDLED();
            }

            uint32_t errInfo = 0;

            err = CO_CANopenInit(me->co,               /* CANopen object */
                                 NULL,                 /* alternate NMT */
                                 NULL,                 /* alternate em */
                                 OD,                   /* Object dictionary */
                                 OD_STATUS_BITS,       /* Optional OD_statusBits */
                                 NMT_CONTROL,          /* CO_NMT_control_t */
                                 FIRST_HB_TIME,        /* firstHBTime_ms */
                                 SDO_SRV_TIMEOUT_TIME, /* SDOserverTimeoutTime_ms */
                                 SDO_CLI_TIMEOUT_TIME, /* SDOclientTimeoutTime_ms */
                                 SDO_CLI_BLOCK,        /* SDOclientBlockTransfer */
                                 me->activeNodeId,
                                 &errInfo);

            if (err != CO_ERROR_NO && err != CO_ERROR_NODE_ID_UNCONFIGURED_LSS) {
                if (err == CO_ERROR_OD_PARAMETERS) {
                    QS_BEGIN_ID(CANOPEN_ERROR_RECORD, AO_canopen->prio);
                        QS_STR("CANopen Error: Object Dictionary entry: ");
                        QS_U32(10, errInfo);
                    QS_END();
                } else {
                    QS_BEGIN_ID(CANOPEN_ERROR_RECORD, AO_canopen->prio);
                        QS_STR("CANopen initialization failed: ");
                        QS_I16(10, err);
                    QS_END();
                }
                QEvt * pEvt = Q_NEW(QEvt, ERROR_SIG);
                QACTIVE_POST(&me->super, pEvt, &me->super);
                return Q_HANDLED();
            }

            err = CO_CANopenInitPDO(me->co, me->co->em, OD, me->activeNodeId, &errInfo);
            if (err != CO_ERROR_NO && err != CO_ERROR_NODE_ID_UNCONFIGURED_LSS) {
                if (err == CO_ERROR_OD_PARAMETERS) {
                    QS_BEGIN_ID(CANOPEN_ERROR_RECORD, AO_canopen->prio);
                        QS_STR("CANopen Error: Object Dictionary entry: ");
                        QS_U32(10, errInfo);
                    QS_END();
                } else {
                    QS_BEGIN_ID(CANOPEN_ERROR_RECORD, AO_canopen->prio);
                        QS_STR("CANopen PDO initialization failed: ");
                        QS_I16(10, err);
                    QS_END();
                }
                QEvt * pEvt = Q_NEW(QEvt, ERROR_SIG);
                QACTIVE_POST(&me->super, pEvt, &me->super);
                return Q_HANDLED();
            }

            QEvt * pEvt = Q_NEW(QEvt, OK_SIG);
            QACTIVE_POST(&me->super, pEvt, &me->super);

            status_ = Q_HANDLED();
            break;
        }
        //${app::canopen::canopen::SM::COMM_INIT::ERROR}
        case ERROR_SIG: {
            status_ = Q_TRAN(&canopen_RESET);
            break;
        }
        //${app::canopen::canopen::SM::COMM_INIT::OK}
        case OK_SIG: {
            status_ = Q_TRAN(&canopen_RUNNING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${app::canopen::canopen::SM::RUNNING} ......................................
static QState canopen_RUNNING(canopen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${app::canopen::canopen::SM::RUNNING}
        case Q_ENTRY_SIG: {
            /* start CAN */
            CO_CANsetNormalMode(me->co->CANmodule);

            me->timestamp_us_prev = TIMER_1us_count();
            me->fast_timestamp_us_prev = TIMER_1us_count();

            QTimeEvt_armX(&me->timerTick, 10, 10);
            QTimeEvt_armX(&me->timerFastTick, 1, 1);

            status_ = Q_HANDLED();
            break;
        }
        //${app::canopen::canopen::SM::RUNNING}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timerTick);
            QTimeEvt_disarm(&me->timerFastTick);

            status_ = Q_HANDLED();
            break;
        }
        //${app::canopen::canopen::SM::RUNNING::TICK, CAN_RX}
        case TICK_SIG: // intentionally fall through
        case CAN_RX_SIG: {
            CO_NMT_reset_cmd_t reset = CO_RESET_NOT;

            uint32_t timeDifference_us = 0U;
            const uint32_t timestamp_us = TIMER_1us_count();

            if(timestamp_us > me->timestamp_us_prev) {
                timeDifference_us = timestamp_us - me->timestamp_us_prev;
            } else {
                timeDifference_us = (0xFFFFFFFFU - me->timestamp_us_prev) + timestamp_us + 1U;
            }
            me->timestamp_us_prev = timestamp_us;

            reset = CO_process(me->co, false, timeDifference_us, NULL);
            //${app::canopen::canopen::SM::RUNNING::TICK, CAN_RX::[ResetDevice]}
            if (reset == CO_RESET_APP) {
                status_ = Q_TRAN(&canopen_RESET);
            }
            //${app::canopen::canopen::SM::RUNNING::TICK, CAN_RX::[ResetComm]}
            else if (CO_RESET_COMM == reset) {
                status_ = Q_TRAN(&canopen_COMM_INIT);
            }
            //${app::canopen::canopen::SM::RUNNING::TICK, CAN_RX::[else]}
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        //${app::canopen::canopen::SM::RUNNING::FAST_TICK}
        case FAST_TICK_SIG: {
            uint32_t timeDifference_us = 0U;
            const uint32_t timestamp_us = TIMER_1us_count();

            if(timestamp_us > me->fast_timestamp_us_prev) {
                timeDifference_us = timestamp_us - me->fast_timestamp_us_prev;
            } else {
                timeDifference_us = (0xFFFFFFFFU - me->fast_timestamp_us_prev) + timestamp_us + 1U;
            }
            me->fast_timestamp_us_prev = timestamp_us;


            if (!me->co->nodeIdUnconfigured && me->co->CANmodule->CANnormal) {
                bool syncWas = false;
                /* get time difference since last function call */
            #if (CO_CONFIG_SYNC) & CO_CONFIG_SYNC_ENABLE
                syncWas = CO_process_SYNC(me->co, timeDifference_us, NULL);
            #endif
            #if (CO_CONFIG_PDO) & CO_CONFIG_RPDO_ENABLE
                CO_process_RPDO(me->co, syncWas, timeDifference_us, NULL);
            #endif
            #if (CO_CONFIG_PDO) & CO_CONFIG_TPDO_ENABLE
                CO_process_TPDO(me->co, syncWas, timeDifference_us, NULL);
            #endif
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${app::canopen::canopen} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${app::canopen::CANOPEN_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::canopen::CANOPEN_ctor} ..............................................
void CANOPEN_ctor(
    FDCAN_HandleTypeDef * fdcan_handle,
    IRQn_Type irq)
{
    canopen * const me = &l_canopen;

    me->CANptr = (void *)fdcan_handle;
    me->irq = irq;

    QTimeEvt_ctorX(&me->timerTick, &me->super, TICK_SIG, 0U);
    QTimeEvt_ctorX(&me->timerFastTick, &me->super, FAST_TICK_SIG, 0U);

    QActive_ctor(&me->super, Q_STATE_CAST(&canopen_initial));
    QACTIVE_START(&me->super,
                  AO_CANOPEN_PRIORITY,
                  canopenQueueSto,
                  Q_DIM(canopenQueueSto),
                  (void *)0,
                  0U,
                  (void *)0);

}
//$enddef${app::canopen::CANOPEN_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${app::canopen::CANOPEN_post_rxEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${app::canopen::CANOPEN_post_rxEvt} ........................................
void CANOPEN_post_rxEvt(void) {
    QEvt * pEvt = Q_NEW(QEvt, CAN_RX_SIG);
    QACTIVE_POST(AO_canopen, (QEvt *)pEvt, AO_canopen);

}
//$enddef${app::canopen::CANOPEN_post_rxEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

